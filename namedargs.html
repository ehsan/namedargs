<!-- vim: set ts=2 sw=2 tw=80 fo=tc et -->
<!DOCTYPE html>
<html>
  <head>
    <title>A proposal for named arguments for C++</title>
    <style>
      code { white-space: pre; }
    </style>
  </head>
  <body>
    <h3>Named arguments</h3>
    <table>
      <tr>
        <th>Document number:</th><td colspan=2></td>
      </tr>
      <tr>
        <th rowspan=2>Authors:</th><td>Ehsan Akhgari</td><td>Mozilla</td>
      </tr>
      <tr>
        <td>Botond Ballo</td><td>Mozilla</td>
      </tr>
      <tr>
        <th>Date:</th><td colspan="2">2014-06-11</td>
      </tr>
    </table>
    <h4>Motivation</h4>
    <p>Large software projects usually have thousands of different functions
    that take a large number of arguments which use the same types.  As a
    result, it's common to see a large number of arguments at the call sites
    and it's difficult to tell what the function exactly does without checking
    its declaration and matching the arguments manually.  Even more
    importantly, it's very common for authors to make mistakes when passing the
    arguments by making incorrect assumptions about the order in which the
    function expects them, which can cause bugs at runtime which are hard to
    prevent and diagnose.</p>
    <p>We therefore need a mechanism in the language in order to help document
    the author's intention at the call site, and prevent them from making
    mistakes at compile time.  We believe that by allowing the author to name
    the arguments that they're passing to the function and have the compiler
    match them with the parameters that the function expects by matching the
    names.</p>
    <h4>Example</h4>
    <p>The below is an example of the kind of code that can be written with what
    is being proposed here.</p>
    <code>
      void draw_rect(int left, int top, int width, int height, bool fill_rect = false);
      int main()
      {
        // Both of the below function calls pass the same set of arguments to draw_rect.
        draw_rect(top: 10, left: 100, width: 640, height: 480);
        draw_rect(100, 10, height: 480, fill_rect: false, width: 640);
      }
    </code>
    <h4>Proposal</h4>
    <h5>Basic semantics</h5>
    <p>Named arguments are defined by extending <em>expression-list</em> to
    accept the syntax of the form <em>identifier: expression</em>.  Non-named
    arguments are referred to as positional arguments.  Positional arguments
    cannot appear after a named argument.  If a function declaration includes
    an ellipsis parameter or is a variadic template function, all of its
    arguments at call sites must be positional.  If a function declaration
    includes default parameters, named arguments may give values to some but
    not all of the optional parameters.  Here is an example:</p>
    <code>
      void foo(int a, char b, std::string c);
      void bar(int a, char b='x', float c=0.1);
      void baz(int a, ...);
      template &lt;class ...T&gt; void qux(T... a);
      void test() {
          foo(1, 'c', "s"); // valid
          foo(1, b: 'c', c: "s"); // valid
          foo(a: 1, 'c', "s"); // invalid -- named argument followed by positional
          foo(1, c: "s", b: 'c'); // valid
          foo(1, 'c', c: "s"); // valid
          bar(1, c: 0.2); // valid
          bar(1, b: 'c'); // valid
          bar(1, c: 0.2, b: 'c'); // valid
          bar(a: 1); // valid
          bar(a: 1, 'c'); // invalid -- named argument followed by positional
          baz(a: 1); // invalid -- ellipsis parameter
          baz(1, foo: 1); // invalid -- ellipsis parameter
          qux(a: 1); // invalid -- variadic template function
      }
    </code>
    <p>If the same function is declared more than once, it can only be called
    using named arguments if the names or lack of for each parameter is exactly
    the same in each declaration.  Here is an example:</p>
    <code>
      void foo(int a, char b, std::string c);
      void foo(int a, char b, std::string x);
      void bar(int a, char b);
      void bar(int x, char b);
      void test() {
          foo(1, 'c', "s"); // valid
          foo(1, 'c', c: "s"); // invalid -- different names for an argument in multiple declarations
          foo(1, 'c', x: "s"); // invalid -- different names for an argument in multiple declarations
          // NOTE: The following has been disallowed for simplicity, we might be able to handle it properly
          bar(1, b: 'c'); // invalid -- different names for an argument in multiple declarations
      }
    </code>
    <p>If the parameter list for a function drops some of the parameter names,
    assuming that parameter N is the last to not have a name, all well-formed
    calls to that function must provide at least N named arguments.  Here is an
    example:</p>
    <code>
      void foo(int, char b, std::string c);
      void bar(int = 1, char b='c', float c=0.1);
      void test() {
          foo(1, c: "s", b: 'c'); // valid
          bar(1, c: 0.2); // valid
          bar(c: 0.2); // invalid - number of positional arguments(0) less than the index of the last unnamed parameter(1)
      }
    </code>
    <p>Functions definitions do not affect calling functions with names
    arguments in any way.  Example:</p>
    <code>
      void foo(int a, char b, std::string c);
      void test() {
          foo(c: "s", a: 1, b: 'c');
      }
      void foo(int x, char y, std::string z) {}
    </code>
    <p>It should also be noted that if the function definition is the first
    declaration of the function, the name of the parameters in the definition
    will be considered here.  Example:</p>
    <code>
      void foo(int a, char b, std::string c) {}
      void test() {
          foo(c: "s", a: 1, b: 'c');
      }
    </code>
    <p>Similarly, if the definition of the function is the first declaration,
    and a following declaration defines different names for the argument, using
    named arguments to call that function would be an error.  Example:</p>
    <code>
      void foo(int a, char b, std::string c) {}
      void foo(int x, char y, std::string z);
      void test() {
          foo(c: "s", a: 1, b: 'c'); // invalid -- different names for an argument in multiple declarations
      }
    </code>
    <p>Function declarations in different translation units can use different
    names for their arguments.</p>
    <h5>Overload resolution</h5>
    <p>Overload resolution needs to be modified slightly in order to handle
    named arguments correctly.  We focus on calls to named functions
    [over.call.func] here.  The language here will need to be extended for
    other cases of overload resolution in the future.</p>
    <p>We need to define a new condition in order to determine whether a
    candidate function is viable or not.  The basic idea is to use the names of
    the named arguments to filter out the candidate functions for which we will
    be unable to assign each argument to a parameter in a function declaration.
    The following gives a more precise definition of how this part of the
    proposal works.</p>
    <p>Let's assume that the function call has M positional arguments and N
    named arguments.  A given candidate is discarded if either of the following
    conditions holds:</p>
    <ul>
      <li>The candidate has fewer than M + N arguments.
      <li>Disregarding the first M parameters of the function, there is a name
      in the list of the rest of the arguments at the call site for which a
      corresponding parameter cannot be found.
      <li>A required parameter of the function remains unmatched after the
      above step.
    </ul>
    <p>For remaining candidate functions, we reorder the N named arguments and
    for i'th parameter of the function (i &lt; M + N) which remains unmatched,
    we fill in a synthetic parameter using its default value.  Note that given
    the above conditions, such parameters are guaranteed to have a default
    value.</p>
    <p>After this step, the rest of the overload resolution steps will be taken
    as normal.</p>
    <p>It should also be noted that we only consider the declaration preceding
    the call site in the above steps.</p>
  </body>
</html>
